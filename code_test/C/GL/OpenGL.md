# OpenGL【Open Graphics Library】用語
- ハードウェアの持つ3次元コンピュータグラフィックス（3DCG）関連の演算機能をソフトウェアから呼び出すための規約を定めたインターフェース（API）標準の一つ。
- APIを規定した"仕様"
- OS に依存しない三次元のグラフィックスライブラリ
- もともと旧Silicon Graphics社（SGI）が自社ソフトウェア向けに開発していたIRIS GLをオープン化したもので、業界団体のクロノス・グループ（Khronos Group）が仕様の標準化を行っている。

- 様々な機種やハードウェア、OSなどに対応した汎用のグラフィックスライブラリで、平面上の2次元グラフィックス（2DCG）、立体的な3次元グラフィックス（3DCG）を描画するための豊富な機能が用意されている。
- Windows環境上ではOpenGLよりも米マイクロソフト（Microsoft）社のDirectX（の3DCG機能であるDirect3D）がよく利用されるが、他の環境やWindowsを含む複数環境の同時対応などが必要な場合にはOpenGLがよく選択される。

- コンピュータのビデオカードなどに専用のグラフィックスチップ（GPU）が搭載されている場合にはその機能を直接呼び出すことができるため、通常のソフトウェアのようにCPUだけで処理する場合に比べ格段に高速に処理することができる。
- GPU内部の動作を細かく記述することができる独自の言語GLSL（OpenGL Shading Language）を規定しており、開発者が独自のプログラマブルシェーダを作成して対応GPUに転送することで様々な表現を行うことができる。

- 規格上ではC言語/C++言語から利用するための仕様を定めているが、他のプログラミング言語から利用するための拡張仕様やライブラリなどが提供されている。
- また、スマートフォンなどの組み込みシステム向けに仕様を簡素化したOpenGL ES（OpenGL for Embedded Systems）や、Webブラウザ上のJavaScriptプログラムから3DCG演算・描画機能を利用するためのWebGLなどの派生規格がある。

- OpenGLそのものはハードウェア寄り（低レベル）のAPIであるため、きめ細かな制御やプログラムの作り込みが可能だが、初心者には取っ付きにくく、また、プログラムが煩雑で膨大になりがちなため、ある程度まとまった単位の高レベルの機能を提供するライブラリを経由して利用することが多い。用途や動作環境、言語の違いにより様々なライブラリが提供されている。

- OpenGLは結果を画面に表示する前提の設計となっているため、GPUの並列演算機能を画像処理以外の汎用の計算用途に用いるGPGPU（GPUコンピューティング）に用いることはできない。その場合はKhronos Groupが策定している姉妹規格とも言うべきOpenCL（Open Computing Language）を用いることが推奨される。


## OpenGLはラスタライザー志向
- CGで画像をレンダリングする手法は、ラスタライズ（rasterizing）によるものとサンプリング（sampling）によるものに分けられる。 
- OpenGLは前者、ラスタライズ方式のレンダリングシステムとして使うことを前提に設計されている。


### ラスタライズ vs サンプリング
- ラスタライズ方式では、透視投影変換などのテクニックを使って、描画したい図形や物体を2次元平面（カメラ画像平面）に射影することで画像を生成します。 
- 先に形状だけをカメラ画像平面に射影してから、法線やテクスチャ座標などの情報を使って色塗りしていくような手法です。

- 一方、サンプリング方式ではシーンの中での光の反射の軌跡をシミュレートします。 
- そして、「カメラにどのように光が入ってきて、その結果それぞれの画素に何色が写り込むのか」を計算することで画像を生成します。 
- レイキャスティング、レイトレーシング、レイマーチングなどの用語が絡むものはサンプリング方式に分類されます。

- ラスタライズ方式の問題は、物体相互の影響が考慮されないことです。 
- シンプルなレンダラーを実装した場合、影や鏡面反射による映り込み・間接照明などが一切反映されず、リアリティのないのっぺりした見た目になってしまいます。 
- これを改善するテクニックとしてシャドウマッピングや環境マッピングなどがあり、うまく活用すれば十分それらしいCGを生成できます。 
- ただ、リアリティを突き詰めようとすればやはり原理的な限界があります。

- 一方、サンプリング方式の手法は現実空間の光の伝搬をシミュレートするという方法を取るので、非常にリアリティの高いCGを生成できます。 
- しかし、素直に全ての光路を計算していてはメモリと時間がいくらあっても足りませんので、シーンの特性に合わせて効率的に計算量を減らすためのノウハウが必要になります。

- 2019年現在、ゲームなどで使われるリアルタイムなレンダリングシステムのほとんどはラスタライズ手法の応用です。 
- ただ、リアルタイムなレイトレーシング手法も徐々に登場してきているので、今後は情勢が変わってくるかもしれません。



## GLUT 【OpenGL Utility Toolkit】
- OpenGLのプログラミングを簡単にするためのライブラリ
- OpenGLに基づいて設計された、FORTRANとANSIに準拠したC言語のクラスライブラリ
- OSのシステムレベルでのI/Oを制御
- OSが描画するウィンドウを制御したり、マウスやキーボードからの入力によってウィンドウを操作したりすることができる。
- 描画されたウィンドウはジオメトリ変換による高品位な立方体や球体として再現することが可能である。
- また、GLUTは、OSを制御するプライマリレベルで機能しているため、OSに依存せずに描画機能を使用することができるという特徴を持っている。


## OpenGL ES (Embedded Systems)
- スマホなどの組込みシステムで動作させることを目的に策定されたOpenGLのサブセット


## WebGL
- OpenGL ESの派生として策定されたJavaScript API
- ブラウザ上でOpenGLを動かすことを目的に作られたもの

## EGL
- penGL ESは、環境非依存の標準APIセットであるため、その中に環境依存のAPIは含まれていない
- しかし、実際には描画ターゲット指定などの環境依存部分があり、このような環境依存部分を切り出したものがEGL


### サーフェス
- グラフィックが表示されている空間

### レンダーバッファ
- 描画処理結果を表示するフロントバッファ

### フレームバッファ
- 描画処理を行うバックバッファ

### ディスプレイ
- ハンドル


### ディスプレイリスト
- 描画実行時に効率よく処理するために、描画に関するコマンド群をひとまとまりにしたもの



### ビューポート
- 表示されるウィンドウのうちのどこに描画領域を設定するか


### コンテキスト
- 内部状態を管理するために用いられる、ハンドル


### プリミティブ
- プリミティブとは、点、線、ポリゴン、ビットマップ、画像のいずれかを指す

### レンダリング
- OpenGL は最終的にプリミティブを2次元の画像に変換しなければならず、プリミティブを画像に変換する処理をレンダリングと言う。




# バーテックスシェーダ(頂点シェーダ) とフラグメントシェーダ(ピクセルシェーダ) 
- ２つのソースを実行時にコンパイル、リンクして、できたプログラムオブジェクトをGPUに送ってグラフィックの描画に使用する。


## バーテックスシェーダ
- 頂点毎に実行され、頂点の位置を出力する。



## フラグメントシェーダ
- 頂点で囲まれた範囲のピクセル毎に呼び出され、その位置の色を出力する。



## YUV
- 色情報の表現形式の一つで、輝度信号（Y）と、輝度信号と青色成分の差（U）、輝度信号と赤色成分の差（V）の3つの組み合わせで色を表現する方式。
- また、そのような形式で表される色空間。

- 人間の目が色の変化よりも明るさの変化に敏感な性質を利用して、輝度情報により多くの情報量を割り当てることで、少ない画質の劣化で高いデータ圧縮率を得ることができる。
    - 人間の目をうまく欺いて、データの容量を削減するための圧縮フォーマット
- テレビ放送の映像信号や、JPEG、MPEGなどの画像・映像データ圧縮に用いられる。コンピュータのディスプレイに表示するにはRGB形式による表現に変換する必要がある。



# REFERENCE
http://wisdom.sakura.ne.jp/system/opengl/index.html
https://www.entis.jp/gls/sample/CubeTest/CubeTest.html

## EGL
https://qiita.com/y-tsutsu/items/1e88212b8532fc693c3c



## C++
https://13mzawa2.hateblo.jp/entry/2016/08/04/210552


