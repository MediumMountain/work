# 動的メモリ確保

## メモリを動的に確保するメリット
- なぜ、メモリを動的に確保する必要があるのでしょうか？ はじめから必要なメモリの量はわかりますか？ プログラムの果たしたい目的によって、メモリを動的に確保しなければならないかどうか、決まります。
- 必ず、プログラムが起動してすぐに、10MBのメモリを使用して、プログラムがすぐに終了してしまうなら、メモリをmallocで確保する必要がないでしょう。自動変数、グローバル変数で十分でしょう。
### 何が嬉しいか
- malloc/freeを使うと何が嬉しいかというと、 必要な量を必要なときに確保することができます。 
- 例えば、通信プログラムは、クライアントが接続してきたときに、クライアントとのメッセージ交換に使うメッセージ用のバッファを動的に確保し、クライアントが切断したら、そのメッセージバッファは不要になるため、解放することができます。

- 処理する最大サイズが10MBだけど、いつも10MB必要ではない、プログラムがあったとして、ずっと10MBのメモリを専有し続けるよりも、10MBが必要になったら、10MBのメモリを確保し、3MBのメモリでいいなら、10MBではなく、3MBのメモリだけ確保すればよいのです。

- 扱いデータの個数やサイズが不明なときや、状況に応じて異なる場合には、動的なメモリの確保と解放のほうが、柔軟にメモリを使用できます。

## メモリを操作する関数

### malloc系関数

- malloc()系(memory allocation)の関数は、第1引数に必要なサイズを指定し、確保したメモリへのポインタを返します。
-  メモリのサイズの指定には、sizeof()を使用して「型」のサイズを調べて、必要な数を掛けあわて、サイズを決めることができます。malloc/free は、C言語の標準ライブラリで提供される関数です。

- メモリは、いくらでも確保できるわけではありません。いろいろな制約によって使用できるメモリ量はかわってきます。

    - OSの上限
    - プロセスの上限(OSなどによって制限されます)
    - 物理的な制限
    - 物理メモリサイズ
    - スワップのサイズ

```
size_t	size = 256;
 
// char型を256個確保する
char	*sp = (char *)malloc( sizeof(char) * size );
 
// int型を256個確保する
int	*ip = (int *)malloc( sizeof(int) * size );
 
// double型を256個確保する
double	*dp = (double *)malloc( sizeof(double) *size );
 
// 256byte 確保する
int	*ip = (int *)malloc( size );
```


- C言語のmalloc/freeには、ガベージコレクション(GC)はありませんので、プログラムが自身でメモリを管理しなければなりません。

### malloc系以外のメモリを取得する関数
- malloc()以外にもメモリを取得する関数が用意されています。 メモリを確保して、文字列を格納する、といったよくある処理を１つの関数で行えます。
    - strdup
    - asprintf
- これらの関数もmalloc()と同様にfree()で不要になったメモリを解放する必要があります。


## 動的メモリにおける注意点



### C++でmalloc() は使わないほうがいいのはなぜですか？
https://jp.quora.com/C-de-malloc-ha-shi-wa-nai-houga-ii-no-ha-naze-desu-ka




# 2次元配列

## ダブルポインタとmalloc()で2次元配列を作成
https://it-ojisan.tokyo/c-double-pointer-2d-array/

- まずは、int型のダブルポインタを宣言します。
```
    int** arr = NULL;
```
- そして、ダブルポインタarrの指し示す先の、ポインタ配列の実体をmalloc()で確保します。
```
    arr = (int**)malloc(sizeof(int*) * ROW);
```
- 更に、ポインタ配列の指し示す先の、int型の配列の実体をmalloc()で確保します。
```
    for(i = 0; i < ROW; i++){
        arr[i] = (int*)malloc(sizeof(int) * COL);
        if(arr[i] == NULL){
            return -1;
        }
    }    
```
- 更に、それぞれの配列の中身に値を詰めていきます。
- 最終的には、2次元配列として、配列の要素にアクセスします。
```
    for(i = 0; i < ROW; i++){
        for(j = 0; j < COL; j++){
            arr[i][j] = i * j;
        }
    }

```

- サンプルコード
    - malloc_2dim_array.c

## トリプルポインタ
https://it-ojisan.tokyo/c-triple-pointer-func/


# 3次元配列
- サンプルコード
    - malloc_3dim_array.c
