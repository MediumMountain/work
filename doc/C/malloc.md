# 動的メモリ確保

## メモリを動的に確保するメリット
- なぜ、メモリを動的に確保する必要があるのでしょうか？ はじめから必要なメモリの量はわかりますか？ プログラムの果たしたい目的によって、メモリを動的に確保しなければならないかどうか、決まります。
- 必ず、プログラムが起動してすぐに、10MBのメモリを使用して、プログラムがすぐに終了してしまうなら、メモリをmallocで確保する必要がないでしょう。自動変数、グローバル変数で十分でしょう。
### 何が嬉しいか
- malloc/freeを使うと何が嬉しいかというと、 必要な量を必要なときに確保することができます。 
- 例えば、通信プログラムは、クライアントが接続してきたときに、クライアントとのメッセージ交換に使うメッセージ用のバッファを動的に確保し、クライアントが切断したら、そのメッセージバッファは不要になるため、解放することができます。

- 処理する最大サイズが10MBだけど、いつも10MB必要ではない、プログラムがあったとして、ずっと10MBのメモリを専有し続けるよりも、10MBが必要になったら、10MBのメモリを確保し、3MBのメモリでいいなら、10MBではなく、3MBのメモリだけ確保すればよいのです。

- 扱いデータの個数やサイズが不明なときや、状況に応じて異なる場合には、動的なメモリの確保と解放のほうが、柔軟にメモリを使用できます。

## メモリを操作する関数

### malloc系関数

- malloc()系(memory allocation)の関数は、第1引数に必要なサイズを指定し、確保したメモリへのポインタを返します。
    - 失敗したときに NULL (ヌルポインタ)を返します。
    - 戻り値型は、void*です。各関数の戻り値は、ポインタの型に合わせて、キャストします。

-  メモリのサイズの指定には、sizeof()を使用して「型」のサイズを調べて、必要な数を掛けあわて、サイズを決めることができます。malloc/free は、C言語の標準ライブラリで提供される関数です。

- メモリは、いくらでも確保できるわけではありません。いろいろな制約によって使用できるメモリ量はかわってきます。

    - OSの上限
    - プロセスの上限(OSなどによって制限されます)
    - 物理的な制限
    - 物理メモリサイズ
    - スワップのサイズ

```
size_t	size = 256;
 
// char型を256個確保する
char	*sp = (char *)malloc( sizeof(char) * size );
 
// int型を256個確保する
int	*ip = (int *)malloc( sizeof(int) * size );
 
// double型を256個確保する
double	*dp = (double *)malloc( sizeof(double) *size );
 
// 256byte 確保する
int	*ip = (int *)malloc( size );
```
- C言語のmalloc/freeには、ガベージコレクション(GC)はありませんので、プログラムが自身でメモリを管理しなければなりません。


### malloc,calloc,allocaの違い

|関数名|説明|  
|:------:|:-------|  
|malloc|	メモリを動的に確保します。メモリ領域は、ゼロクリアされません。|
|calloc|	メモリを動的に確保します。確保したメモリを自動的にゼロクリアします。|
|alloca|	メモリをスタックフレームから割り当てます。スコープから外れるときに自動的に解放されます。明示的にfreeで解放してはいけません。|
|realloc|	メモリを動的に再確保します。渡されたポインタのメモリをコピーします。渡されたポインタの領域は解放します。|  


#  



### malloc系以外のメモリを取得する関数
- malloc()以外にもメモリを取得する関数が用意されています。 メモリを確保して、文字列を格納する、といったよくある処理を１つの関数で行えます。
    - strdup
    - asprintf
- これらの関数もmalloc()と同様にfree()で不要になったメモリを解放する必要があります。


## 動的メモリにおける注意点



### C++でmalloc() は使わないほうがいいのはなぜですか？
https://jp.quora.com/C-de-malloc-ha-shi-wa-nai-houga-ii-no-ha-naze-desu-ka




# 2次元配列

## ダブルポインタとmalloc()で2次元配列を作成
https://it-ojisan.tokyo/c-double-pointer-2d-array/

- まずは、int型のダブルポインタを宣言します。
```
    int** arr = NULL;
```
- そして、ダブルポインタarrの指し示す先の、ポインタ配列の実体をmalloc()で確保します。
```
    arr = (int**)malloc(sizeof(int*) * ROW);
```
- 更に、ポインタ配列の指し示す先の、int型の配列の実体をmalloc()で確保します。
```
    for(i = 0; i < ROW; i++){
        arr[i] = (int*)malloc(sizeof(int) * COL);
        if(arr[i] == NULL){
            return -1;
        }
    }    
```
- 更に、それぞれの配列の中身に値を詰めていきます。
- 最終的には、2次元配列として、配列の要素にアクセスします。
```
    for(i = 0; i < ROW; i++){
        for(j = 0; j < COL; j++){
            arr[i][j] = i * j;
        }
    }

```

- サンプルコード
    - malloc_2dim_array.c

## トリプルポインタ
https://it-ojisan.tokyo/c-triple-pointer-func/


# 3次元配列
- サンプルコード
    - malloc_3dim_array.c




## メモリの再確保 realloc  
- malloc()によって確保したメモリが足りなくなったときに、さらにメモリのサイズを大きくする必要があれば、realloc()を使って、メモリサイズを増やすことができます。 
- ただし、純粋に今確保している領域が後ろに伸びるわけではありません。
- 適当な場所にメモリを確保しなおし、そこにデータをコピーすることになります。
-  すでに確保しているメモリが大きいほど、コピーする量も多くなり、スピードが遅くなります。

- realloc()の処理の内容を簡単に説明すると以下の流れになります。

1. メモリの確保(旧領域)
1. メモリの再確保
1. メモリの確保(新領域)
1. 旧領域から新領域へデータのコピー
1. 旧領域の解放


- realloc()は、確保した新しい領域へのアドレス（ポインタ）を返します。
- reallocは、必ず成功するとは限りません。realloc()は、失敗したとき NULL を返します
- そのため、第一引数に渡す、ポインタで、reallocの戻り値を受け取るべきではありません。

```
int *p;
 
p = (int*)malloc(10 * sizeof(int));
if (! p) {
	err(EXIT_FAILURE, "can not malloc");
}
int *tmp;
tmp = (int*)realloc(p, 20 * sizeof(int));
if (! tmp) {
	free(p);
	err(EXIT_FAILURE, "can not realloc");
}
p = tmp;
```

## スワップ
- OSの実装によるため、どのような条件で引き起こされるかは、環境によりますが、一般的なOSでは、実行中のプログラム達によってメモリを消費されていき、物理メモリが足りなくなると、OSはスワップを使いはじめます。
- OSは、ファイルシステムにメモリ上のデータを逃します。

## スラッシング
- スワップを使用するとOS、プログラムの動作が遅くなっていきます。
-  プログラムが必要なデータがスワップにある場合、一度、メモリに戻さなければなりません。
- メモリのデータをスワップにどかして、スワップからデータを読むといった動作が必要なります。 
- このメモリとスワップの入れ替えが激しく起きて、プログラムがほとんど停止状態に陥ることをスラッシング(thrashing)と呼びます。