# OpenGL【Open Graphics Library】用語
- ハードウェアの持つ3次元コンピュータグラフィックス（3DCG）関連の演算機能をソフトウェアから呼び出すための規約を定めたインターフェース（API）標準の一つ。
- APIを規定した"仕様"
- OS に依存しない三次元のグラフィックスライブラリ(システムに依存しないプログラムを記述できる)
- もともと旧Silicon Graphics社（SGI）が自社ソフトウェア向けに開発していたIRIS GLをオープン化したもので、業界団体のクロノス・グループ（Khronos Group）が仕様の標準化を行っている。

- 様々な機種やハードウェア、OSなどに対応した汎用のグラフィックスライブラリで、平面上の2次元グラフィックス（2DCG）、立体的な3次元グラフィックス（3DCG）を描画するための豊富な機能が用意されている。
- Windows環境上ではOpenGLよりも米マイクロソフト（Microsoft）社のDirectX（の3DCG機能であるDirect3D）がよく利用されるが、他の環境やWindowsを含む複数環境の同時対応などが必要な場合にはOpenGLがよく選択される。

- コンピュータのビデオカードなどに専用のグラフィックスチップ（GPU）が搭載されている場合にはその機能を直接呼び出すことができるため、通常のソフトウェアのようにCPUだけで処理する場合に比べ格段に高速に処理することができる。
- GPU内部の動作を細かく記述することができる独自の言語GLSL（OpenGL Shading Language）を規定しており、開発者が独自のプログラマブルシェーダを作成して対応GPUに転送することで様々な表現を行うことができる。

- 規格上ではC言語/C++言語から利用するための仕様を定めているが、他のプログラミング言語から利用するための拡張仕様やライブラリなどが提供されている。
- また、スマートフォンなどの組み込みシステム向けに仕様を簡素化したOpenGL ES（OpenGL for Embedded Systems）や、Webブラウザ上のJavaScriptプログラムから3DCG演算・描画機能を利用するためのWebGLなどの派生規格がある。

- OpenGLそのものはハードウェア寄り（低レベル）のAPIであるため、きめ細かな制御やプログラムの作り込みが可能だが、初心者には取っ付きにくく、また、プログラムが煩雑で膨大になりがちなため、ある程度まとまった単位の高レベルの機能を提供するライブラリを経由して利用することが多い。用途や動作環境、言語の違いにより様々なライブラリが提供されている。

- OpenGLは結果を画面に表示する前提の設計となっているため、GPUの並列演算機能を画像処理以外の汎用の計算用途に用いるGPGPU（GPUコンピューティング）に用いることはできない。その場合はKhronos Groupが策定している姉妹規格とも言うべきOpenCL（Open Computing Language）を用いることが推奨される。


## OpenGLはラスタライザー志向
- CGで画像をレンダリングする手法は、ラスタライズ（rasterizing）によるものとサンプリング（sampling）によるものに分けられる。 
- OpenGLは前者、ラスタライズ方式のレンダリングシステムとして使うことを前提に設計されている。


### ラスタライズ vs サンプリング
- ラスタライズ方式では、透視投影変換などのテクニックを使って、描画したい図形や物体を2次元平面（カメラ画像平面）に射影することで画像を生成します。 
- 先に形状だけをカメラ画像平面に射影してから、法線やテクスチャ座標などの情報を使って色塗りしていくような手法です。

- 一方、サンプリング方式ではシーンの中での光の反射の軌跡をシミュレートします。 
- そして、「カメラにどのように光が入ってきて、その結果それぞれの画素に何色が写り込むのか」を計算することで画像を生成します。 
- レイキャスティング、レイトレーシング、レイマーチングなどの用語が絡むものはサンプリング方式に分類されます。

- ラスタライズ方式の問題は、物体相互の影響が考慮されないことです。 
- シンプルなレンダラーを実装した場合、影や鏡面反射による映り込み・間接照明などが一切反映されず、リアリティのないのっぺりした見た目になってしまいます。 
- これを改善するテクニックとしてシャドウマッピングや環境マッピングなどがあり、うまく活用すれば十分それらしいCGを生成できます。 
- ただ、リアリティを突き詰めようとすればやはり原理的な限界があります。

- 一方、サンプリング方式の手法は現実空間の光の伝搬をシミュレートするという方法を取るので、非常にリアリティの高いCGを生成できます。 
- しかし、素直に全ての光路を計算していてはメモリと時間がいくらあっても足りませんので、シーンの特性に合わせて効率的に計算量を減らすためのノウハウが必要になります。

- 2019年現在、ゲームなどで使われるリアルタイムなレンダリングシステムのほとんどはラスタライズ手法の応用です。 
- ただ、リアルタイムなレイトレーシング手法も徐々に登場してきているので、今後は情勢が変わってくるかもしれません。


## レンダリングパイプライン
- ラスタライズ方式は座標変換により形状データのスクリーンへの投影像を求め, それを走査変換によりスクリーン上で画素に展開 (ラスタライズ) して画像を生成します. 
- これはおおよその手順に整理されており, レンダリングパイプラインと呼ばれています.


## GLUT 【OpenGL Utility Toolkit】
- OpenGLのプログラミングを簡単にするためのライブラリ
- OpenGLに基づいて設計された、FORTRANとANSIに準拠したC言語のクラスライブラリ
- OSのシステムレベルでのI/Oを制御
- OSが描画するウィンドウを制御したり、マウスやキーボードからの入力によってウィンドウを操作したりすることができる。
- 描画されたウィンドウはジオメトリ変換による高品位な立方体や球体として再現することが可能である。
- また、GLUTは、OSを制御するプライマリレベルで機能しているため、OSに依存せずに描画機能を使用することができるという特徴を持っている。


## OpenGL ES (Embedded Systems)
- スマホなどの組込みシステムで動作させることを目的に策定されたOpenGLのサブセット


## WebGL
- OpenGL ESの派生として策定されたJavaScript API
- ブラウザ上でOpenGLを動かすことを目的に作られたもの

## EGL
- OpenGL ESは、環境非依存の標準APIセットであるため、その中に環境依存のAPIは含まれていない
- しかし、実際には描画ターゲット指定などの環境依存部分があり、このような環境依存部分を切り出したものがEGL


## 頂点(vertex)
- OpenGL ES は、n個の頂点を空間上に浮かべ（座標データを用意し）、これらを結んで塗りつぶすことで図形を描く。


### ウィンドウ
- 描画先

### サーフェス
- グラフィックが表示されている空間

### レンダーバッファ
- 描画処理結果を表示するフロントバッファ

### フレームバッファ
- 描画処理を行うバックバッファ


### 深度バッファ(Depth buffer)
- 深度バッファはポリゴンの前後関係（ｚ座標）のデータを格納している。
- 深度バッファを使わない場合、OpenGLは後に描画されたものの方が手前にある様に表示される。

- 深度バッファを有効化/無効化するには
```
glEnable(GL_DEPTH_TEST); // 有効化
glDisable(GL_DEPTH_TEST);// 無効化
```

- また、深度バッファを毎度の描画ループでクリアする必要がある。
```
glClear(GL_DEPTH_BUFFER_BIT);
```

### ディスプレイ
- ハンドル


### ディスプレイリスト
- 描画実行時に効率よく処理するために、描画に関するコマンド群をひとまとまりにしたもの



### ビューポート
- 表示されるウィンドウのうちのどこに描画領域を設定するか


### シザー矩形
- ウィンドウ上のどの部分に描画するか

```
// シザー矩形（描画しない領域）の設定
// ウィンドウの左下ｘ,y座標、右上x,y座標 の順番で指定
// OpenGLでは左下が原点にある
glScissor(10, 10, 100, 100); 
```


### レンダリングコンテキスト（コンテキスト）
- 内部状態（OpenGL ESのステート）を管理するために用いられる、ハンドル

- EGLによって作成する。
- 実際のレンダリングを開始する前に適切なサーフェスにアタッチされる必要がある。


- Windowsの場合、レンダリングコンテキストをデバイスコンテキストと結びつけ、描画を行う。
    - デバイスコンテキストはディスプレイやプリンターといったデバイスの描画属性に関する情報を保持する Windows のデータ構造体
    - GDI が管理するデータ構造であり，出力デバイスの属性が格納される。


####　GDI
- Graphics Device Interface (GDI) は，Windows の描画処理を担当するコンポーネントの一つです。
- GDI 関数を用いることで，ディスプレイやプリンタといった出力デバイスに，図形，テキスト，画像等を描画することができます。
- GDI 関数による描画は，出力デバイスを問わず，ほぼ同様の記述で行うことができます。


### プリミティブ
- プリミティブとは、点、線、ポリゴン、ビットマップ、画像のいずれかを指す

### レンダリング
- OpenGL は最終的にプリミティブを2次元の画像に変換しなければならず、プリミティブを画像に変換する処理をレンダリングと言う。




# シェーダ
- バーテックスシェーダ(頂点シェーダ) とフラグメントシェーダ(ピクセルシェーダ) 
- ２つのソースを実行時にコンパイル、リンクして、できたプログラムオブジェクトをGPUに送ってグラフィックの描画に使用する。
- シェーダはプログラムから見るとただの文字列

## シェーダオブジェクト
- シェーダを１つだけもつ。
- シェーダソースコードが与えられ、オブジェクト形式にコンパイルされる。
- コンパイル後、シェーダオブジェクトはプログラムオブジェクトにアタッチできる。


## プログラムオブジェクト
- 複数のシェーダオブジェクトをアタッチできる。
    - OpenGLESでは頂点シェーダとフラグメントシェーダを１つずつ
- プログラムオブジェクトはリンクされ、実行形式になる


## バーテックスシェーダ
- 頂点毎に実行され、頂点の位置を出力する。



## ジオメトリシェーダ
- バーテックスシェーダとフラグメントシェーダの間に位置するシェーダ
- バーテックスシェーダとフラグメントシェーダの二つだけでは，例えば，入力された三角形ポリゴンから点群を生成して描画する， ポリゴンのテッセレーション，ディスプレースメントマップなどの処理は難しい。 
- これらの処理のためにはプリミティブごとの処理を行い，かつ，新しいプリミティブを作り出すことができるシェーダが必要である。 これがジオメトリシェーダである。



## フラグメントシェーダ
- フラグメント(ピクセル)ごとの処理
- 頂点で囲まれた範囲のピクセル毎に呼び出され、その位置の色を出力する。




### フラグメント
- 単一のピクセルに対応し、色の値、デプス値、（場合によっては）テクスチャ座標の値をもつもの


## 環境マッピング


## カリング
- カリングとは画⾯に描画されないところを事前に調べて、描画処理を⾏わなくし⾼速化をする⽅法。

### 視錐台カリング
- 座標変換の話でも出てきた視錐台。視錐台に⼊らないオブジェクトは描画しないことによって⾼速化する⽅法。
### オクルージョンカリング
- オブジェクトが複数ある場合、⼿前にあるオブジェクトによって後ろのオブジェクトが隠れるなら、そのオブジェクトは描画しないことで⾼速化する⽅法。



## Zバッファ（深度バッファ）
- 描画進行中のフレームにおいて「各ピクセルがどういう前後関係にあるのか」を表すのに都合のよい奥行き情報（≒Z座標値）を記録する作業領域


# REFERENCE
http://wisdom.sakura.ne.jp/system/opengl/index.html
https://www.entis.jp/gls/sample/CubeTest/CubeTest.html

https://www.oit.ac.jp/is/L231/pukiwiki/?%E6%84%9F%E8%A6%9A%E3%83%A1%E3%83%87%E3%82%A3%E3%82%A2%E7%A0%94%E7%A9%B6%E5%AE%A4/OpenGL

## EGL
https://qiita.com/y-tsutsu/items/1e88212b8532fc693c3c



## C++
https://13mzawa2.hateblo.jp/entry/2016/08/04/210552


